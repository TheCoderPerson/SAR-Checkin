<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAR Check-In/Out</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font as preferred */
        }
        /* Hide scrollbar for video element */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        /* Basic styling for modal */
        .modal { display: none; /* Hidden by default */ }
        .modal.active { display: flex; /* Show when active */ }
        /* Ensure video feed fills the scanner area */
        #scannerVideo {
            width: 100%;
            height: auto;
            max-height: 60vh; /* Limit height on larger screens */
            object-fit: cover; /* Cover the area */
        }
        #qrScannerCanvas {
            display: none; /* Hidden canvas for processing */
        }
         /* Custom button styles */
        .btn {
            @apply inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2;
        }
        .btn-primary {
            @apply text-white bg-indigo-600 hover:bg-indigo-700 focus:ring-indigo-500;
        }
        .btn-secondary {
            @apply text-indigo-700 bg-indigo-100 hover:bg-indigo-200 focus:ring-indigo-500;
        }
        .btn-danger {
            @apply text-white bg-red-600 hover:bg-red-700 focus:ring-red-500;
        }
        .btn-warning {
            @apply text-white bg-yellow-500 hover:bg-yellow-600 focus:ring-yellow-400;
        }
        .btn-success {
             @apply text-white bg-green-600 hover:bg-green-700 focus:ring-green-500;
        }
        .btn-icon {
            @apply p-2 rounded-full; /* Make icon buttons circular */
        }
        /* Input field styling */
        .input-field {
            @apply block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm;
        }
        /* Select field styling */
        .select-field {
             @apply block w-full px-3 py-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm;
        }
        /* Message styling */
        .message {
            @apply p-4 rounded-md mb-4 text-sm;
        }
        .message-success {
            @apply bg-green-100 text-green-700;
        }
        .message-error {
            @apply bg-red-100 text-red-700;
        }
        .message-info {
            @apply bg-blue-100 text-blue-700;
        }
        .message-warning {
            @apply bg-yellow-100 text-yellow-700;
        }
    </style>
</head>
<body class="bg-gray-100">

    <header class="bg-indigo-600 text-white shadow-md sticky top-0 z-50">
        <nav class="container mx-auto px-4 py-3 flex justify-between items-center">
            <h1 class="text-xl font-bold">SAR Check-In/Out</h1>
            <div>
                <button id="showUserAppBtn" class="btn btn-secondary mr-2">User App</button>
                <button id="showAdminAppBtn" class="btn btn-secondary">Admin App</button>
            </div>
        </nav>
    </header>

    <main class="container mx-auto p-4 mt-4">

        <section id="userApp" class="bg-white p-6 rounded-lg shadow-md mb-6">
            <h2 class="text-2xl font-semibold mb-4 text-gray-800">User Information</h2>
            <div id="userMessage" class="message hidden"></div> <form id="userForm" class="space-y-4">
                <div>
                    <label for="firstName" class="block text-sm font-medium text-gray-700">First Name</label>
                    <input type="text" id="firstName" name="firstName" required class="input-field">
                </div>
                <div>
                    <label for="lastName" class="block text-sm font-medium text-gray-700">Last Name</label>
                    <input type="text" id="lastName" name="lastName" required class="input-field">
                </div>
                <div>
                    <label for="sarNumber" class="block text-sm font-medium text-gray-700">SAR#</label>
                    <input type="text" id="sarNumber" name="sarNumber" required class="input-field">
                </div>
                <div>
                    <label for="firstAidLevel" class="block text-sm font-medium text-gray-700">First Aid Level</label>
                    <select id="firstAidLevel" name="firstAidLevel" required class="select-field">
                        <option value="">Select Level</option>
                        <option value="FA">FA (First Aid)</option>
                        <option value="WFA">WFA (Wilderness First Aid)</option>
                        <option value="WFR">WFR (Wilderness First Responder)</option>
                        <option value="EMT">EMT (Emergency Medical Technician)</option>
                    </select>
                </div>
                <div>
                    <label for="phoneNumber" class="block text-sm font-medium text-gray-700">Phone Number</label>
                    <input type="tel" id="phoneNumber" name="phoneNumber" required class="input-field">
                </div>
                <div class="flex space-x-3 pt-2">
                    <button type="submit" id="saveUserBtn" class="btn btn-primary flex-1">Save Information</button>
                    <button type="button" id="generateQrBtn" class="btn btn-success flex-1">Generate QR Code</button>
                    <button type="button" id="clearUserFormBtn" class="btn btn-secondary">Clear</button>
                </div>
            </form>
            <div id="qrCodeContainer" class="mt-6 flex flex-col items-center hidden">
                <h3 class="text-lg font-medium mb-2">Your QR Code</h3>
                <div id="qrcode" class="border p-2 inline-block rounded-md bg-white"></div>
                <p class="text-sm text-gray-600 mt-2">Admins can scan this to check you in/out.</p>
            </div>
        </section>

        <section id="adminApp" class="bg-white p-6 rounded-lg shadow-md hidden">
            <h2 class="text-2xl font-semibold mb-4 text-gray-800">Admin Dashboard</h2>
            <div id="adminMessage" class="message hidden"></div> <div class="mb-4 border-b border-gray-200">
                <nav class="-mb-px flex space-x-8" aria-label="Tabs">
                    <button id="tabEvents" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-indigo-500 text-indigo-600" aria-current="page">
                        Events
                    </button>
                    <button id="tabCreateEvent" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">
                        Create Event
                    </button>
                    <button id="tabScanQR" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">
                        Scan QR
                    </button>
                </nav>
            </div>

            <div id="eventsView">
                <h3 class="text-xl font-semibold mb-3 text-gray-700">Manage Events</h3>
                 <div class="mb-4">
                    <label for="eventFilter" class="sr-only">Filter Events</label>
                    <select id="eventFilter" class="select-field w-auto">
                        <option value="active">Active Events</option>
                        <option value="past">Past Events</option>
                    </select>
                 </div>
                <div id="activeEventsList" class="space-y-3">
                    <p class="text-gray-500">Loading active events...</p>
                </div>
                 <div id="pastEventsList" class="space-y-3 hidden">
                    <p class="text-gray-500">Loading past events...</p>
                </div>
            </div>

            <div id="createEventView" class="hidden">
                <h3 class="text-xl font-semibold mb-3 text-gray-700">Create New Event</h3>
                <form id="createEventForm" class="space-y-4">
                    <div>
                        <label for="eventName" class="block text-sm font-medium text-gray-700">Event Name</label>
                        <input type="text" id="eventName" name="eventName" required class="input-field">
                    </div>
                    <div>
                        <label for="eventType" class="block text-sm font-medium text-gray-700">Event Type</label>
                        <select id="eventType" name="eventType" required class="select-field">
                            <option value="">Select Type</option>
                            <option value="training">Training</option>
                            <option value="search">Search</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Location (Optional)</label>
                        <p class="text-xs text-gray-500 mb-2">Enter Lat/Lon manually OR use the 'Get Current Location' button.</p>
                        <div class="flex items-center space-x-2 mb-2">
                            <input type="number" step="any" id="eventLatitude" name="latitude" placeholder="Latitude (-90 to 90)" class="input-field flex-1" min="-90" max="90">
                            <input type="number" step="any" id="eventLongitude" name="longitude" placeholder="Longitude (-180 to 180)" class="input-field flex-1" min="-180" max="180">
                        </div>
                        <button type="button" id="getEventLocationBtn" class="btn btn-secondary w-full"><i class="fas fa-map-marker-alt mr-1"></i> Get Current Location</button>
                        <p id="locationStatus" class="text-xs text-gray-500 mt-1"></p>
                    </div>
                    <button type="submit" class="btn btn-primary w-full">Create Event</button>
                </form>
            </div>

            <div id="scanQrView" class="hidden">
                <h3 class="text-xl font-semibold mb-3 text-gray-700">Scan Member QR Code</h3>
                 <div class="mb-4">
                    <label for="scanEventSelect" class="block text-sm font-medium text-gray-700">Select Active Event for Check-in/Out</label>
                    <select id="scanEventSelect" class="select-field">
                        <option value="">-- Select Event --</option>
                        </select>
                </div>
                <div id="scannerContainer" class="relative border border-gray-300 rounded-md overflow-hidden aspect-video bg-black flex items-center justify-center">
                    <video id="scannerVideo" playsinline class="no-scrollbar"></video>
                    <canvas id="qrScannerCanvas"></canvas> <div class="absolute inset-0 border-4 border-red-500 opacity-75" style="clip-path: polygon(0% 0%, 0% 100%, 25% 100%, 25% 25%, 75% 25%, 75% 75%, 25% 75%, 25% 100%, 100% 100%, 100% 0%);"></div>
                     <p id="scannerMessage" class="absolute bottom-2 left-2 right-2 text-white bg-black bg-opacity-50 p-1 rounded text-xs text-center">Align QR code within the red box</p>
                </div>
                <button id="startScanBtn" class="btn btn-primary w-full mt-4">Start Scanner</button>
                <button id="stopScanBtn" class="btn btn-danger w-full mt-2 hidden">Stop Scanner</button>
                <div id="scanResult" class="mt-4 text-center"></div>
            </div>

            <div id="eventDetailsModal" class="modal fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full items-center justify-center z-50">
                <div class="relative mx-auto p-5 border w-full max-w-3xl shadow-lg rounded-md bg-white">
                    <div class="flex justify-between items-center border-b pb-3 mb-3">
                        <h3 class="text-xl font-semibold text-gray-900" id="modalEventName">Event Details</h3>
                        <button id="closeModalBtn" class="text-gray-400 hover:text-gray-600">
                            <i class="fas fa-times fa-lg"></i>
                        </button>
                    </div>
                    <div id="modalContent" class="max-h-[70vh] overflow-y-auto">
                        <p id="modalEventInfo" class="text-sm text-gray-600 mb-4"></p>
                        <h4 class="text-lg font-semibold mb-2 text-gray-800">Participants</h4>
                         <div class="mb-3">
                            <input type="text" id="participantSearch" placeholder="Search by Name or SAR#" class="input-field">
                         </div>
                        <div class="overflow-x-auto">
                            <table class="min-w-full divide-y divide-gray-200">
                                <thead class="bg-gray-50">
                                    <tr>
                                        <th scope="col" class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
                                        <th scope="col" class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">SAR#</th>
                                        <th scope="col" class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                                        <th scope="col" class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Check-In</th>
                                        <th scope="col" class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Check-Out</th>
                                        <th scope="col" class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Hours</th>
                                    </tr>
                                </thead>
                                <tbody id="participantsTableBody" class="bg-white divide-y divide-gray-200">
                                    </tbody>
                            </table>
                        </div>
                        <div id="modalNoParticipants" class="text-center text-gray-500 py-4 hidden">No participants checked in yet.</div>
                    </div>
                    <div class="mt-4 pt-4 border-t flex flex-wrap gap-2 justify-end">
                        <button id="exportCsvBtn" class="btn btn-secondary"><i class="fas fa-file-csv mr-1"></i> Export CSV</button>
                        <button id="exportPdfBtn" class="btn btn-secondary"><i class="fas fa-file-pdf mr-1"></i> Export PDF</button>
                        <button id="emailReportBtn" class="btn btn-secondary"><i class="fas fa-envelope mr-1"></i> Email Report</button>
                        <button id="closeEventBtn" class="btn btn-warning"><i class="fas fa-door-closed mr-1"></i> Close Event</button>
                        <button id="deleteEventBtn" class="btn btn-danger"><i class="fas fa-trash mr-1"></i> Delete Event</button>
                    </div>
                </div>
            </div>

             <div id="checkoutConfirmModal" class="modal fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full items-center justify-center z-50">
                <div class="relative mx-auto p-5 border w-full max-w-md shadow-lg rounded-md bg-white">
                     <h3 class="text-lg font-semibold text-gray-900 mb-4">Confirm Check-Out</h3>
                     <p id="checkoutConfirmText" class="mb-4 text-sm text-gray-700">Are you sure you want to check out [Name]?</p>
                     <div class="flex justify-end space-x-2">
                         <button id="cancelCheckoutBtn" class="btn btn-secondary">Cancel</button>
                         <button id="confirmCheckoutBtn" class="btn btn-primary">Check Out</button>
                     </div>
                </div>
            </div>

        </section>

    </main>

    <script>
        // --- Constants and Global Variables ---
        const DB_NAME = 'SAR_DB';
        const DB_VERSION = 1; // Increment DB version if schema changes
        const USER_STORE_NAME = 'userProfile'; // For LocalStorage
        const EVENTS_STORE_NAME = 'events';
        // const PARTICIPANTS_STORE_NAME = 'participants'; // Keeping participants embedded in events for now

        let db; // IndexedDB database instance
        let qrCodeInstance = null; // qrcode.js instance
        let currentEditEventId = null; // Track which event is being viewed/edited in modal
        let videoStream = null; // For QR scanner video
        let scanInterval = null; // Interval ID for QR scanning (using requestAnimationFrame now)

        // DOM Elements (Grouped for clarity)
        // App Sections & Navigation
        const userAppSection = document.getElementById('userApp');
        const adminAppSection = document.getElementById('adminApp');
        const showUserAppBtn = document.getElementById('showUserAppBtn');
        const showAdminAppBtn = document.getElementById('showAdminAppBtn');

        // User App
        const userForm = document.getElementById('userForm');
        const saveUserBtn = document.getElementById('saveUserBtn');
        const generateQrBtn = document.getElementById('generateQrBtn');
        const clearUserFormBtn = document.getElementById('clearUserFormBtn');
        const qrCodeContainer = document.getElementById('qrCodeContainer');
        const qrcodeDiv = document.getElementById('qrcode');
        const userMessage = document.getElementById('userMessage');

        // Admin App - General & Tabs
        const adminMessage = document.getElementById('adminMessage');
        const tabEvents = document.getElementById('tabEvents');
        const tabCreateEvent = document.getElementById('tabCreateEvent');
        const tabScanQR = document.getElementById('tabScanQR');

        // Admin App - Events View
        const eventsView = document.getElementById('eventsView');
        const activeEventsList = document.getElementById('activeEventsList');
        const pastEventsList = document.getElementById('pastEventsList');
        const eventFilter = document.getElementById('eventFilter');

        // Admin App - Create Event View
        const createEventView = document.getElementById('createEventView');
        const createEventForm = document.getElementById('createEventForm');
        const getEventLocationBtn = document.getElementById('getEventLocationBtn');
        const eventLatitudeInput = document.getElementById('eventLatitude');
        const eventLongitudeInput = document.getElementById('eventLongitude');
        const locationStatus = document.getElementById('locationStatus');

        // Admin App - Scan QR View
        const scanQrView = document.getElementById('scanQrView');
        const scanEventSelect = document.getElementById('scanEventSelect');
        const scannerContainer = document.getElementById('scannerContainer');
        const scannerVideo = document.getElementById('scannerVideo');
        const qrScannerCanvas = document.getElementById('qrScannerCanvas');
        const startScanBtn = document.getElementById('startScanBtn');
        const stopScanBtn = document.getElementById('stopScanBtn');
        const scanResult = document.getElementById('scanResult');
        const scannerMessage = document.getElementById('scannerMessage');

        // Event Details Modal
        const eventDetailsModal = document.getElementById('eventDetailsModal');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const modalEventName = document.getElementById('modalEventName');
        const modalEventInfo = document.getElementById('modalEventInfo');
        const participantsTableBody = document.getElementById('participantsTableBody');
        const modalNoParticipants = document.getElementById('modalNoParticipants');
        const participantSearch = document.getElementById('participantSearch');
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        const exportPdfBtn = document.getElementById('exportPdfBtn');
        const emailReportBtn = document.getElementById('emailReportBtn');
        const closeEventBtn = document.getElementById('closeEventBtn');
        const deleteEventBtn = document.getElementById('deleteEventBtn');

        // Checkout Confirm Modal
        const checkoutConfirmModal = document.getElementById('checkoutConfirmModal');
        const checkoutConfirmText = document.getElementById('checkoutConfirmText');
        const cancelCheckoutBtn = document.getElementById('cancelCheckoutBtn');
        const confirmCheckoutBtn = document.getElementById('confirmCheckoutBtn');
        let userToCheckOut = null; // Store user data for checkout confirmation


        // --- Utility Functions ---

        /**
         * Displays a message in the specified message area.
         * @param {HTMLElement} element - The message container element.
         * @param {string} text - The message text.
         * @param {'success' | 'error' | 'info' | 'warning'} type - The message type.
         * @param {number} duration - Duration in ms to show the message (0 for permanent).
         */
        function showMessage(element, text, type = 'info', duration = 5000) {
            element.textContent = text;
            element.className = `message message-${type}`; // Reset classes and apply new ones
            element.classList.remove('hidden');
            if (duration > 0) {
                setTimeout(() => {
                    // Check if the message is still the same one before hiding
                    if (element.textContent === text) {
                         element.classList.add('hidden');
                    }
                }, duration);
            }
        }

        /**
         * Hides the specified message area.
         * @param {HTMLElement} element - The message container element.
         */
        function hideMessage(element) {
             element.classList.add('hidden');
             element.textContent = '';
             element.className = 'message hidden'; // Reset classes
        }

        /**
         * Formats a Date object into a readable string.
         * @param {Date | string | number} dateInput - The date to format.
         * @returns {string} - Formatted date string or 'N/A'.
         */
        function formatDate(dateInput) {
            if (!dateInput) return 'N/A';
            try {
                const date = new Date(dateInput);
                if (isNaN(date.getTime())) return 'N/A'; // Invalid date
                // Use locale-specific format, include time
                return date.toLocaleString(undefined, {
                    year: 'numeric', month: 'short', day: 'numeric',
                    hour: 'numeric', minute: '2-digit', hour12: true
                 });
            } catch (e) {
                console.error("Error formatting date:", dateInput, e);
                return 'N/A';
            }
        }

        /**
         * Calculates total hours between two dates.
         * @param {Date | string | number} startTime - The start time.
         * @param {Date | string | number} endTime - The end time.
         * @returns {string} - Total hours as a string (e.g., "2.5 hrs") or 'N/A'.
         */
        function calculateHours(startTime, endTime) {
            if (!startTime || !endTime) return 'N/A';
            try {
                const start = new Date(startTime);
                const end = new Date(endTime);
                if (isNaN(start.getTime()) || isNaN(end.getTime())) return 'N/A';
                const diffMs = end - start;
                if (diffMs < 0) return 'Invalid'; // End time before start time
                const diffHrs = diffMs / (1000 * 60 * 60);
                return `${diffHrs.toFixed(1)} hrs`;
            } catch (e) {
                console.error("Error calculating hours:", startTime, endTime, e);
                return 'N/A';
            }
        }

        /**
         * Gets current GPS location.
         * @returns {Promise<{latitude: number, longitude: number}>}
         */
        function getCurrentLocation() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject(new Error("Geolocation is not supported by this browser."));
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        resolve({
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        });
                    },
                    (error) => {
                        let message = "Error getting location: ";
                        switch (error.code) {
                            case error.PERMISSION_DENIED: message += "User denied the request for Geolocation."; break;
                            case error.POSITION_UNAVAILABLE: message += "Location information is unavailable."; break;
                            case error.TIMEOUT: message += "The request to get user location timed out."; break;
                            case error.UNKNOWN_ERROR: message += "An unknown error occurred."; break;
                        }
                        reject(new Error(message));
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } // Options
                );
            });
        }


        // --- IndexedDB Setup and Helpers ---

        /**
         * Opens the IndexedDB database.
         */
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.error);
                    reject("Database error: " + event.target.errorCode);
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("Database opened successfully.");
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    console.log("Database upgrade needed.");
                    db = event.target.result;
                    if (!db.objectStoreNames.contains(EVENTS_STORE_NAME)) {
                        // Use autoIncrementing key 'id'
                        const eventStore = db.createObjectStore(EVENTS_STORE_NAME, { keyPath: 'id', autoIncrement: true });
                        // Create indexes for searching/sorting
                        eventStore.createIndex('eventName', 'eventName', { unique: false });
                        eventStore.createIndex('creationTime', 'creationTime', { unique: false });
                        eventStore.createIndex('closed', 'closed', { unique: false });
                        console.log(`Object store ${EVENTS_STORE_NAME} created.`);
                    }
                    // If DB_VERSION increases, add migration logic here based on oldVersion
                    // const oldVersion = event.oldVersion;
                    // if (oldVersion < NEW_VERSION) { /* migrate schema */ }
                };
            });
        }

        /**
         * Adds an item to an IndexedDB object store.
         * @param {string} storeName - The name of the object store.
         * @param {object} item - The item to add.
         * @returns {Promise<number>} - The ID of the added item.
         */
        function addItem(storeName, item) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("Database not initialized."); return; }
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.add(item);

                request.onsuccess = (event) => resolve(event.target.result); // Returns the key of the new object
                request.onerror = (event) => reject(`Error adding item to ${storeName}: ${event.target.error}`);
                transaction.oncomplete = () => console.log(`Transaction complete: Added item to ${storeName}`);
                transaction.onerror = (event) => reject(`Transaction error adding item to ${storeName}: ${event.target.error}`);
            });
        }

        /**
         * Gets an item from an IndexedDB object store by its key.
         * @param {string} storeName - The name of the object store.
         * @param {any} key - The key of the item to retrieve.
         * @returns {Promise<object|undefined>} - The retrieved item or undefined if not found.
         */
        function getItem(storeName, key) {
            return new Promise((resolve, reject) => {
                 if (!db) { reject("Database not initialized."); return; }
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);

                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(`Error getting item from ${storeName}: ${event.target.error}`);
            });
        }

         /**
         * Updates an item in an IndexedDB object store.
         * @param {string} storeName - The name of the object store.
         * @param {object} item - The item to update (must include the key).
         * @returns {Promise<void>}
         */
        function updateItem(storeName, item) {
            return new Promise((resolve, reject) => {
                 if (!db) { reject("Database not initialized."); return; }
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(item); // put() updates if key exists, adds otherwise

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(`Error updating item in ${storeName}: ${event.target.error}`);
                transaction.oncomplete = () => console.log(`Transaction complete: Updated item in ${storeName}`);
                transaction.onerror = (event) => reject(`Transaction error updating item in ${storeName}: ${event.target.error}`);
            });
        }

        /**
         * Deletes an item from an IndexedDB object store by its key.
         * @param {string} storeName - The name of the object store.
         * @param {any} key - The key of the item to delete.
         * @returns {Promise<void>}
         */
        function deleteItem(storeName, key) {
            return new Promise((resolve, reject) => {
                 if (!db) { reject("Database not initialized."); return; }
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);

                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(`Error deleting item from ${storeName}: ${event.target.error}`);
                 transaction.oncomplete = () => console.log(`Transaction complete: Deleted item from ${storeName}`);
                transaction.onerror = (event) => reject(`Transaction error deleting item from ${storeName}: ${event.target.error}`);
            });
        }


        /**
         * Gets all items from an IndexedDB object store, optionally filtering by index.
         * @param {string} storeName - The name of the object store.
         * @param {string} [indexName] - Optional index name to filter on.
         * @param {any} [indexValue] - Optional value for the index filter.
         * @returns {Promise<Array<object>>} - An array of items.
         */
        function getAllItems(storeName, indexName = null, indexValue = null) {
            return new Promise((resolve, reject) => {
                 if (!db) { reject("Database not initialized."); return; }
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                let request;

                if (indexName !== null && indexValue !== null) {
                    try {
                        const index = store.index(indexName);
                        // Use IDBKeyRange.only for exact match
                        request = index.getAll(IDBKeyRange.only(indexValue));
                    } catch (e) {
                         // Handle cases where the index might not exist (e.g., during development/migration)
                        console.error(`Error accessing index '${indexName}' in store '${storeName}':`, e);
                        // Fallback to getting all items if index fails? Or reject? Rejecting is safer.
                        reject(`Error accessing index '${indexName}': ${e.message}`);
                        return; // Stop execution
                    }
                } else {
                    request = store.getAll();
                }

                request.onsuccess = (event) => resolve(event.target.result || []);
                request.onerror = (event) => reject(`Error getting all items from ${storeName}: ${event.target.error}`);
            });
        }


        // --- User App Logic ---

        /**
         * Saves user data to LocalStorage.
         */
        function saveUserData() {
            const userData = {
                firstName: userForm.firstName.value.trim(),
                lastName: userForm.lastName.value.trim(),
                sarNumber: userForm.sarNumber.value.trim(),
                firstAidLevel: userForm.firstAidLevel.value,
                phoneNumber: userForm.phoneNumber.value.trim(),
            };

            // Basic Validation
            if (!userData.firstName || !userData.lastName || !userData.sarNumber || !userData.firstAidLevel || !userData.phoneNumber) {
                 showMessage(userMessage, 'Please fill in all fields.', 'error');
                 return false; // Indicate failure
            }

            try {
                localStorage.setItem(USER_STORE_NAME, JSON.stringify(userData));
                showMessage(userMessage, 'Information saved successfully!', 'success');
                generateQrBtn.disabled = false; // Enable QR generation after saving
                return true; // Indicate success
            } catch (e) {
                console.error("Error saving to LocalStorage:", e);
                showMessage(userMessage, 'Error saving data. Storage might be full.', 'error');
                return false; // Indicate failure
            }
        }

        /**
         * Loads user data from LocalStorage into the form.
         */
        function loadUserData() {
            try {
                const savedData = localStorage.getItem(USER_STORE_NAME);
                if (savedData) {
                    const userData = JSON.parse(savedData);
                    userForm.firstName.value = userData.firstName || '';
                    userForm.lastName.value = userData.lastName || '';
                    userForm.sarNumber.value = userData.sarNumber || '';
                    userForm.firstAidLevel.value = userData.firstAidLevel || '';
                    userForm.phoneNumber.value = userData.phoneNumber || '';
                    generateQrBtn.disabled = false; // Enable QR button if data exists
                    showMessage(userMessage, 'Loaded saved information.', 'info');
                } else {
                    generateQrBtn.disabled = true; // Disable QR button if no data
                }
            } catch (e) {
                console.error("Error loading from LocalStorage:", e);
                 showMessage(userMessage, 'Could not load saved data.', 'error');
                 generateQrBtn.disabled = true;
            }
        }

        /**
         * Generates and displays the QR code.
         */
        function generateQRCode() {
            const savedData = localStorage.getItem(USER_STORE_NAME);
            if (!savedData) {
                 showMessage(userMessage, 'Please save your information first.', 'warning');
                 return;
            }

             // Ensure data is up-to-date from the form before generating
             if (!saveUserData()) {
                 showMessage(userMessage, 'Please ensure all fields are filled correctly before generating QR code.', 'error');
                 return; // Stop if save failed (e.g., validation error)
             }
             const currentData = localStorage.getItem(USER_STORE_NAME); // Get the latest saved data


            qrCodeContainer.classList.remove('hidden');
            qrcodeDiv.innerHTML = ''; // Clear previous QR code

            try {
                if (qrCodeInstance) {
                    qrCodeInstance.clear(); // Clear previous instance if exists
                    qrCodeInstance.makeCode(currentData);
                } else {
                    qrCodeInstance = new QRCode(qrcodeDiv, {
                        text: currentData,
                        width: 200,
                        height: 200,
                        colorDark: "#000000",
                        colorLight: "#ffffff",
                        correctLevel: QRCode.CorrectLevel.H // High correction level
                    });
                }
                 showMessage(userMessage, 'QR Code generated successfully.', 'success');
            } catch (error) {
                console.error("QR Code generation error:", error);
                 showMessage(userMessage, 'Failed to generate QR code.', 'error');
                qrCodeContainer.classList.add('hidden');
            }
        }

        /**
         * Clears the user form and hides the QR code.
         */
        function clearUserForm() {
            userForm.reset();
            qrCodeContainer.classList.add('hidden');
            qrcodeDiv.innerHTML = '';
            generateQrBtn.disabled = true; // Disable QR until saved again
            hideMessage(userMessage);
            // Optionally clear localStorage too, or keep it for reload
            // localStorage.removeItem(USER_STORE_NAME);
            // showMessage(userMessage, 'Form cleared.', 'info');
        }


        // --- Admin App Logic ---

        /**
         * Switches between Admin App tabs/views.
         * @param {string} targetViewId - The ID of the view to show ('eventsView', 'createEventView', 'scanQrView').
         */
        function switchAdminView(targetViewId) {
            // Hide all views
            eventsView.classList.add('hidden');
            createEventView.classList.add('hidden');
            scanQrView.classList.add('hidden');

            // Deactivate all tabs
            tabEvents.classList.remove('border-indigo-500', 'text-indigo-600');
            tabEvents.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
            tabCreateEvent.classList.remove('border-indigo-500', 'text-indigo-600');
            tabCreateEvent.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
            tabScanQR.classList.remove('border-indigo-500', 'text-indigo-600');
            tabScanQR.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');

            // Show target view and activate corresponding tab
            const targetView = document.getElementById(targetViewId);
            let targetTab;
            if (targetView) {
                targetView.classList.remove('hidden');
                if (targetViewId === 'eventsView') targetTab = tabEvents;
                else if (targetViewId === 'createEventView') targetTab = tabCreateEvent;
                else if (targetViewId === 'scanQrView') targetTab = tabScanQR;

                if (targetTab) {
                    targetTab.classList.add('border-indigo-500', 'text-indigo-600');
                    targetTab.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                    targetTab.setAttribute('aria-current', 'page');
                }
                 hideMessage(adminMessage); // Clear messages on view switch
            }

            // Stop scanner if navigating away from scan view
             if (targetViewId !== 'scanQrView' && videoStream) {
                 stopScanner();
             }
        }

        /**
         * Fetches and displays events based on the filter (active/past).
         */
        async function displayEvents() {
            const filterValue = eventFilter.value;
            activeEventsList.innerHTML = ''; // Clear lists
            pastEventsList.innerHTML = '';
            scanEventSelect.innerHTML = '<option value="">-- Select Event --</option>'; // Clear and reset scanner dropdown

            try {
                // Fetch all events first
                const allEvents = await getAllItems(EVENTS_STORE_NAME);
                const activeEvents = [];
                const pastEvents = [];

                // Sort and filter events
                allEvents.sort((a, b) => new Date(b.creationTime) - new Date(a.creationTime)); // Sort newest first

                allEvents.forEach(event => {
                    if (event.closed) {
                        pastEvents.push(event);
                    } else {
                        activeEvents.push(event);
                        // Populate scanner dropdown only with active events
                        const option = document.createElement('option');
                        option.value = event.id;
                        option.textContent = `${event.eventName} (${event.eventType})`;
                        scanEventSelect.appendChild(option);
                    }
                });

                // Show/Hide lists based on filter
                activeEventsList.classList.toggle('hidden', filterValue !== 'active');
                pastEventsList.classList.toggle('hidden', filterValue !== 'past');

                const listToShow = filterValue === 'active' ? activeEvents : pastEvents;
                const containerToShow = filterValue === 'active' ? activeEventsList : pastEventsList;

                if (listToShow.length === 0) {
                    containerToShow.innerHTML = `<p class="text-gray-500 italic">No ${filterValue} events found.</p>`;
                } else {
                    // Create and append cards safely
                    listToShow.forEach(event => {
                        try {
                            const eventCard = createEventCard(event); // This function now handles potential errors
                            containerToShow.appendChild(eventCard);
                        } catch (cardError) {
                             console.error(`Error creating card for event ID ${event?.id}:`, cardError);
                             // Optionally display an error card or skip
                             const errorCard = document.createElement('div');
                             errorCard.className = 'p-4 border rounded-md shadow-sm bg-red-100 text-red-700';
                             errorCard.textContent = `Error displaying event: ${event?.eventName || 'Unknown'} (ID: ${event?.id}). ${cardError.message}`;
                             containerToShow.appendChild(errorCard);
                        }
                    });
                }
                 hideMessage(adminMessage); // Clear any previous loading errors if successful

            } catch (error) {
                console.error("Error fetching or processing events:", error);
                // Display error in the message area AND in the list area
                showMessage(adminMessage, `Error loading events: ${error}`, 'error', 0); // Show permanent error
                activeEventsList.innerHTML = `<p class="text-red-500">Error loading active events. ${error.message}</p>`;
                pastEventsList.innerHTML = `<p class="text-red-500">Error loading past events. ${error.message}</p>`;
            }
        }

        /**
         * Creates an HTML card element for an event.
         * Includes error handling for missing location data.
         * @param {object} event - The event data object.
         * @returns {HTMLElement} - The event card element.
         * @throws {Error} If essential event data is missing.
         */
        function createEventCard(event) {
            // Basic check for essential event data
             if (!event || typeof event.id === 'undefined' || !event.eventName) {
                throw new Error("Invalid event data provided to createEventCard.");
            }

            const card = document.createElement('div');
            card.className = 'p-4 border rounded-md shadow-sm bg-white hover:shadow-md transition-shadow duration-200';
            const participantCount = event.participants ? event.participants.length : 0;
            const checkedInCount = event.participants ? event.participants.filter(p => !p.checkOutTime).length : 0;

            // --- Safely access location data ---
            let locationString = 'Location: Not specified';
            // Check if location object exists AND latitude/longitude are valid numbers
            if (event.location && typeof event.location.latitude === 'number' && typeof event.location.longitude === 'number' && !isNaN(event.location.latitude) && !isNaN(event.location.longitude)) {
                try {
                    // Use try-catch for toFixed just in case, though type check should prevent it
                    locationString = `Location: ${event.location.latitude.toFixed(4)}, ${event.location.longitude.toFixed(4)}`;
                } catch (e) {
                    console.error(`Error formatting location for event ${event.id}:`, e);
                    locationString = 'Location: Invalid data'; // Indicate bad data if toFixed fails
                }
            }
            // --- End safe location access ---


            card.innerHTML = `
                <div class="flex justify-between items-start">
                    <div>
                        <h4 class="text-lg font-semibold text-indigo-700">${event.eventName}</h4>
                        <p class="text-sm text-gray-600">Type: ${event.eventType || 'N/A'}</p>
                        <p class="text-sm text-gray-600">Created: ${formatDate(event.creationTime)}</p>
                        <p class="text-sm text-gray-600">Status: <span class="${event.closed ? 'text-red-600' : 'text-green-600'} font-medium">${event.closed ? 'Closed' : 'Active'}</span></p>
                        <p class="text-sm text-gray-600">Participants: ${participantCount} (${checkedInCount} currently checked in)</p>
                        <p class="text-xs text-gray-500">${locationString}</p>
                    </div>
                    <button data-event-id="${event.id}" class="view-event-details-btn btn btn-secondary btn-sm">
                       <i class="fas fa-eye mr-1"></i> View Details
                    </button>
                </div>
            `;
             // Add event listener to the button
             const viewButton = card.querySelector('.view-event-details-btn');
             if (viewButton) {
                 viewButton.addEventListener('click', () => {
                     openEventDetailsModal(event.id);
                 });
             } else {
                console.warn(`Could not find view button for event card ${event.id}`);
             }


            return card;
        }


        /**
         * Handles the creation of a new event.
         * @param {Event} e - The form submission event.
         */
        async function handleCreateEvent(e) {
            e.preventDefault();
            hideMessage(adminMessage);

            // --- Get and Validate Location Data ---
            let latitude = eventLatitudeInput.value.trim();
            let longitude = eventLongitudeInput.value.trim();
            let locationData = null; // Default to null if no valid location provided

            if (latitude !== '' || longitude !== '') {
                 // If either field has input, try to validate both
                 const latNum = parseFloat(latitude);
                 const lonNum = parseFloat(longitude);

                 if (isNaN(latNum) || isNaN(lonNum) || latNum < -90 || latNum > 90 || lonNum < -180 || lonNum > 180) {
                      showMessage(adminMessage, 'Invalid Latitude or Longitude entered. Please enter valid numbers within range or leave blank.', 'error');
                      return; // Stop creation if manually entered coords are invalid
                 }
                 // If valid, store the numbers
                 locationData = {
                     latitude: latNum,
                     longitude: lonNum
                 };
            }
             // --- End Location Handling ---


            const eventData = {
                eventName: createEventForm.eventName.value.trim(),
                eventType: createEventForm.eventType.value,
                location: locationData, // Use validated or null location data
                creationTime: new Date().toISOString(),
                closed: false,
                participants: [] // Initialize with empty participants array
            };

            if (!eventData.eventName || !eventData.eventType) {
                 showMessage(adminMessage, 'Please provide event name and type.', 'error');
                 return;
            }

            try {
                const newEventId = await addItem(EVENTS_STORE_NAME, eventData);
                showMessage(adminMessage, `Event "${eventData.eventName}" created successfully (ID: ${newEventId}).`, 'success');
                createEventForm.reset(); // Clear the form
                locationStatus.textContent = ''; // Clear location status
                // Inputs are cleared by reset()
                await displayEvents(); // Refresh the event list
                switchAdminView('eventsView'); // Switch back to events view
            } catch (error) {
                console.error("Error creating event:", error);
                 showMessage(adminMessage, `Failed to create event: ${error}`, 'error');
            }
        }

        /**
         * Gets the current location and populates the event form fields.
         * This will overwrite any manually entered values.
         */
        async function handleGetEventLocation() {
            locationStatus.textContent = 'Getting location...';
            locationStatus.classList.remove('text-red-500', 'text-green-500');
            locationStatus.classList.add('text-gray-500');
            getEventLocationBtn.disabled = true;

            try {
                const coords = await getCurrentLocation();
                // Update the input fields, overwriting manual entry
                eventLatitudeInput.value = coords.latitude.toFixed(6);
                eventLongitudeInput.value = coords.longitude.toFixed(6);
                locationStatus.textContent = 'Location acquired successfully.';
                locationStatus.classList.remove('text-gray-500', 'text-red-500');
                locationStatus.classList.add('text-green-500');
            } catch (error) {
                console.error("Error getting location:", error);
                locationStatus.textContent = `Error: ${error.message}`;
                locationStatus.classList.remove('text-gray-500', 'text-green-500');
                locationStatus.classList.add('text-red-500');
                 showMessage(adminMessage, `Could not get location: ${error.message}`, 'error');
            } finally {
                getEventLocationBtn.disabled = false;
            }
        }

        // --- QR Code Scanning Logic ---

        /**
         * Starts the QR code scanner.
         */
        async function startScanner() {
            hideMessage(adminMessage);
            scanResult.textContent = '';
            const selectedEventId = scanEventSelect.value;

            if (!selectedEventId) {
                showMessage(adminMessage, 'Please select an active event first.', 'warning');
                return;
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                 showMessage(adminMessage, 'Camera access (getUserMedia) is not supported by your browser or requires HTTPS.', 'error');
                 return;
            }

            startScanBtn.classList.add('hidden');
            stopScanBtn.classList.remove('hidden');
            scannerMessage.textContent = 'Initializing camera...';

            try {
                // Prefer back camera
                const constraints = {
                    video: { facingMode: "environment" }
                };
                videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                scannerVideo.srcObject = videoStream;
                // Ensure video plays, especially on mobile
                await scannerVideo.play();

                 // Wait for video metadata to load to get dimensions
                 scannerVideo.onloadedmetadata = () => {
                     scannerMessage.textContent = 'Align QR code within the red box';
                     // Set canvas dimensions based on video
                     qrScannerCanvas.height = scannerVideo.videoHeight;
                     qrScannerCanvas.width = scannerVideo.videoWidth;
                     // Start scanning loop
                     if (!scanInterval) { // Prevent multiple intervals if clicked quickly
                        scanInterval = requestAnimationFrame(tick); // Use requestAnimationFrame for smoother performance
                     }
                 };
                 // Handle cases where metadata might already be loaded
                 if (scannerVideo.readyState >= scannerVideo.HAVE_METADATA) {
                     scannerVideo.onloadedmetadata(); // Trigger manually if already loaded
                 }


            } catch (err) {
                console.error("Error accessing camera:", err);
                let errMsg = `Error accessing camera: ${err.message}.`;
                 if (err.name === "NotAllowedError") {
                     errMsg += " Please grant camera permission.";
                 } else if (err.name === "NotFoundError") {
                     errMsg += " No camera found or facingMode='environment' not available.";
                 } else if (err.name === "NotReadableError") {
                     errMsg += " Camera might be in use by another application.";
                 }
                 showMessage(adminMessage, errMsg, 'error');
                 stopScanner(); // Clean up if start failed
            }
        }

        /**
         * Stops the QR code scanner and releases the camera.
         */
        function stopScanner() {
            if (scanInterval) {
                cancelAnimationFrame(scanInterval); // Stop the animation frame loop
                scanInterval = null;
            }
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
                if (scannerVideo) scannerVideo.srcObject = null; // Clear video source
            }
            startScanBtn.classList.remove('hidden');
            stopScanBtn.classList.add('hidden');
            if (scannerMessage) scannerMessage.textContent = 'Scanner stopped.';
            // Keep scan result visible? Optional.
            // scanResult.textContent = '';
        }

        /**
         * Scanning loop function called by requestAnimationFrame.
         */
        function tick() {
            // Ensure video and stream are still active before proceeding
            if (!videoStream || !scannerVideo || scannerVideo.readyState < scannerVideo.HAVE_ENOUGH_DATA) {
                // If stream stopped or video not ready, request next frame and exit
                if (videoStream && !scanInterval) { // Check if interval needs restarting
                    scanInterval = requestAnimationFrame(tick);
                }
                return;
            }

            // Set interval for next frame *before* processing current one
            // This ensures continuous scanning even if processing takes time
            scanInterval = requestAnimationFrame(tick);


            const canvasContext = qrScannerCanvas.getContext("2d", { willReadFrequently: true }); // Optimize for frequent reads
             // Ensure canvas dimensions match video, might change if device rotates or camera changes
             if (qrScannerCanvas.width !== scannerVideo.videoWidth || qrScannerCanvas.height !== scannerVideo.videoHeight) {
                qrScannerCanvas.width = scannerVideo.videoWidth;
                qrScannerCanvas.height = scannerVideo.videoHeight;
             }

            canvasContext.drawImage(scannerVideo, 0, 0, qrScannerCanvas.width, qrScannerCanvas.height);
            const imageData = canvasContext.getImageData(0, 0, qrScannerCanvas.width, qrScannerCanvas.height);

            try {
                const code = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: "dontInvert", // Or "attemptBoth" if needed
                });

                if (code && code.data) { // Check if code and data exist
                    // --- QR Code Found ---
                    scannerMessage.textContent = 'QR Code Detected!';
                    // Stop scanner *before* processing to prevent multiple scans of same code
                    stopScanner();
                    // Process the data asynchronously
                    handleScannedData(code.data);
                    // No need to request another frame here, scanner is stopped
                    return;
                } else {
                     scannerMessage.textContent = 'Scanning... Align QR code within the red box';
                }
            } catch (e) {
                // jsQR might throw errors on certain inputs
                console.error("jsQR error during scanning:", e);
                scannerMessage.textContent = 'Error during scan processing.';
                // Continue scanning? Or stop? Continue for now.
            }

        }

        /**
         * Processes the data obtained from the scanned QR code.
         * @param {string} qrData - The string data from the QR code.
         */
        async function handleScannedData(qrData) {
            scanResult.textContent = `Processing QR data...`;
            hideMessage(adminMessage);
            const selectedEventId = parseInt(scanEventSelect.value, 10); // Ensure it's a number

            if (!selectedEventId || isNaN(selectedEventId)) {
                 showMessage(adminMessage, 'Error: No valid event selected for check-in.', 'error');
                 scanResult.textContent = 'Error: No event selected.';
                 return;
            }

            let userData;
            try {
                userData = JSON.parse(qrData);
                // Validate expected user data fields
                if (!userData || !userData.sarNumber || !userData.firstName || !userData.lastName) {
                    throw new Error("Invalid QR code data format.");
                }
                 scanResult.textContent = `QR Decoded: ${userData.firstName} ${userData.lastName} (SAR# ${userData.sarNumber})`;

            } catch (error) {
                console.error("Error parsing QR data:", error);
                 showMessage(adminMessage, 'Invalid QR code data. Please scan a valid user QR code.', 'error');
                 scanResult.textContent = 'Error: Invalid QR code.';
                 return;
            }

            // --- Check-in/Check-out Logic ---
            try {
                const event = await getItem(EVENTS_STORE_NAME, selectedEventId);
                if (!event) {
                     showMessage(adminMessage, `Error: Event with ID ${selectedEventId} not found.`, 'error');
                     scanResult.textContent = 'Error: Event not found.';
                     return;
                }
                 if (event.closed) {
                    showMessage(adminMessage, `Event "${event.eventName}" is closed. Cannot check in/out.`, 'warning');
                    scanResult.textContent = 'Event is closed.';
                    return;
                }


                const existingParticipantIndex = event.participants.findIndex(p => p.sarNumber === userData.sarNumber);
                let currentCoords = null;

                // Try to get location for check-in/out
                try {
                    currentCoords = await getCurrentLocation();
                } catch (locationError) {
                     console.warn("Could not get location for check-in/out:", locationError);
                     showMessage(adminMessage, `Warning: Could not get location. Proceeding without coordinates. (${locationError.message})`, 'warning', 8000);
                }


                if (existingParticipantIndex !== -1) {
                    // Participant exists, check if already checked in
                    const participant = event.participants[existingParticipantIndex];
                    if (!participant.checkOutTime) {
                        // --- Already Checked In: Prompt for Check-Out ---
                        userToCheckOut = { eventId: selectedEventId, participantIndex: existingParticipantIndex, participantData: participant, location: currentCoords };
                        checkoutConfirmText.textContent = `Check out ${participant.firstName} ${participant.lastName} (SAR# ${participant.sarNumber})?`;
                        checkoutConfirmModal.classList.add('active');

                    } else {
                        // --- Already Checked Out: Re-Check-In (Treat as new check-in) ---
                         showMessage(adminMessage, `${userData.firstName} ${userData.lastName} was previously checked out. Checking them in again.`, 'info');
                         const newParticipantRecord = {
                            ...userData, // Copy basic user info
                            checkInTime: new Date().toISOString(),
                            checkInLocation: currentCoords,
                            checkOutTime: null,
                            checkOutLocation: null,
                            totalHours: null // Reset hours
                         };
                         event.participants.push(newParticipantRecord); // Add as a new entry for re-check-in
                         await updateItem(EVENTS_STORE_NAME, event);
                         showMessage(adminMessage, `${userData.firstName} ${userData.lastName} checked IN successfully (re-check-in).`, 'success');
                         scanResult.textContent = `${userData.firstName} checked IN (re-check-in).`;
                    }
                } else {
                    // --- New Participant: Check-In ---
                    const newParticipant = {
                        ...userData, // Copy all fields from QR
                        checkInTime: new Date().toISOString(),
                        checkInLocation: currentCoords,
                        checkOutTime: null,
                        checkOutLocation: null,
                        totalHours: null
                    };
                    event.participants.push(newParticipant);
                    await updateItem(EVENTS_STORE_NAME, event);
                    showMessage(adminMessage, `${userData.firstName} ${userData.lastName} checked IN successfully.`, 'success');
                    scanResult.textContent = `${userData.firstName} checked IN.`;
                }

            } catch (error) {
                console.error("Error during check-in/out process:", error);
                 showMessage(adminMessage, `Check-in/out failed: ${error}`, 'error');
                 scanResult.textContent = 'Check-in/out failed.';
            }
        }

        /**
         * Handles the confirmation of a checkout action.
         */
        async function handleConfirmCheckout() {
             if (!userToCheckOut) return;

             const { eventId, participantIndex, participantData, location } = userToCheckOut;
             hideMessage(adminMessage); // Hide previous messages

             try {
                 const event = await getItem(EVENTS_STORE_NAME, eventId);
                 if (!event || !event.participants || typeof event.participants[participantIndex] === 'undefined') {
                     throw new Error("Event or participant data mismatch during checkout.");
                 }

                 // Update the specific participant record
                 event.participants[participantIndex].checkOutTime = new Date().toISOString();
                 event.participants[participantIndex].checkOutLocation = location; // Record checkout location
                 // Total hours will be calculated on display/export

                 await updateItem(EVENTS_STORE_NAME, event);
                 showMessage(adminMessage, `${participantData.firstName} ${participantData.lastName} checked OUT successfully.`, 'success');
                 scanResult.textContent = `${participantData.firstName} checked OUT.`; // Update scan result area too

             } catch (error) {
                 console.error("Error during checkout confirmation:", error);
                 showMessage(adminMessage, `Checkout failed: ${error}`, 'error');
                 scanResult.textContent = 'Checkout failed.';
             } finally {
                 // Clean up and close modal
                 userToCheckOut = null;
                 checkoutConfirmModal.classList.remove('active');
             }
         }


        // --- Event Details Modal Logic ---

        /**
         * Opens the event details modal and populates it with data.
         * @param {number} eventId - The ID of the event to display.
         */
        async function openEventDetailsModal(eventId) {
             hideMessage(adminMessage); // Clear dashboard messages
             currentEditEventId = eventId; // Store the current event ID

             try {
                 const event = await getItem(EVENTS_STORE_NAME, eventId);
                 if (!event) {
                     showMessage(adminMessage, `Event with ID ${eventId} not found.`, 'error');
                     return;
                 }

                 // Populate Modal Header and Info
                 modalEventName.textContent = `${event.eventName} (${event.eventType || 'N/A'})`;

                 // --- Safely display location in modal ---
                 let modalLocationString = 'Location: Not specified';
                 if (event.location && typeof event.location.latitude === 'number' && typeof event.location.longitude === 'number' && !isNaN(event.location.latitude) && !isNaN(event.location.longitude)) {
                     try {
                         modalLocationString = `Location: ${event.location.latitude.toFixed(4)}, ${event.location.longitude.toFixed(4)}`;
                     } catch (e) {
                         modalLocationString = 'Location: Invalid data';
                     }
                 }
                 // --- End safe location display ---

                 modalEventInfo.innerHTML = `
                     Created: ${formatDate(event.creationTime)} <br>
                     Status: <span class="${event.closed ? 'text-red-600' : 'text-green-600'} font-medium">${event.closed ? 'Closed' : 'Active'}</span> <br>
                     ${modalLocationString}
                 `;

                 // Update button states based on event status
                 closeEventBtn.disabled = event.closed;
                 deleteEventBtn.disabled = false; // Allow deletion always? Or only for closed events? Allowing always for now.
                 exportCsvBtn.disabled = false;
                 exportPdfBtn.disabled = false;
                 emailReportBtn.disabled = false;
                 participantSearch.value = ''; // Clear search on open

                 // Populate Participants Table
                 renderParticipantsTable(event.participants || []);

                 // Show the modal
                 eventDetailsModal.classList.add('active');

             } catch (error) {
                 console.error(`Error loading event details for ID ${eventId}:`, error);
                 showMessage(adminMessage, `Failed to load event details: ${error}`, 'error');
             }
        }

        /**
         * Renders the participants table within the modal.
         * @param {Array<object>} participants - Array of participant objects for the event.
         * @param {string} [searchTerm=''] - Optional search term to filter participants.
         */
        function renderParticipantsTable(participants, searchTerm = '') {
             participantsTableBody.innerHTML = ''; // Clear existing rows
             const lowerSearchTerm = searchTerm.toLowerCase().trim();

             const filteredParticipants = participants.filter(p => {
                 if (!p) return false; // Skip null/undefined participants if any exist
                 if (!lowerSearchTerm) return true; // Show all if no search term
                 const fullName = `${p.firstName || ''} ${p.lastName || ''}`.toLowerCase();
                 const sarNum = (p.sarNumber || '').toLowerCase();
                 return fullName.includes(lowerSearchTerm) || sarNum.includes(lowerSearchTerm);
             });


             if (filteredParticipants.length === 0) {
                 modalNoParticipants.classList.remove('hidden');
                 modalNoParticipants.textContent = searchTerm ? 'No participants match your search.' : 'No participants checked in yet.';
             } else {
                 modalNoParticipants.classList.add('hidden');
                 filteredParticipants.forEach(p => {
                     const row = participantsTableBody.insertRow();
                     row.className = 'hover:bg-gray-50';
                     const status = p.checkOutTime
                         ? '<span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-red-100 text-red-800">Checked Out</span>'
                         : '<span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">Checked In</span>';

                     const totalHrs = calculateHours(p.checkInTime, p.checkOutTime);

                     row.innerHTML = `
                         <td class="px-4 py-2 whitespace-nowrap text-sm font-medium text-gray-900">${p.firstName || 'N/A'} ${p.lastName || ''}</td>
                         <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500">${p.sarNumber || 'N/A'}</td>
                         <td class="px-4 py-2 whitespace-nowrap text-sm">${status}</td>
                         <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500">${formatDate(p.checkInTime)}</td>
                         <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500">${formatDate(p.checkOutTime)}</td>
                         <td class="px-4 py-2 whitespace-nowrap text-sm text-gray-500">${totalHrs}</td>
                     `;
                 });
             }
        }


        /**
         * Closes the event details modal.
         */
        function closeEventDetailsModal() {
            eventDetailsModal.classList.remove('active');
            currentEditEventId = null; // Clear the current event ID
        }

        /**
         * Handles the closing of an event.
         */
        async function handleCloseEvent() {
            if (currentEditEventId === null) return;
             hideMessage(adminMessage);

            if (!confirm(`Are you sure you want to close event ID ${currentEditEventId}? Any remaining checked-in participants will be automatically checked out.`)) {
                return;
            }

            try {
                const event = await getItem(EVENTS_STORE_NAME, currentEditEventId);
                if (!event) throw new Error("Event not found.");
                if (event.closed) {
                    showMessage(adminMessage, "Event is already closed.", "info");
                    closeEventDetailsModal();
                    await displayEvents(); // Refresh list even if already closed
                    return;
                }

                const now = new Date().toISOString();
                let checkedOutCount = 0;

                // Force checkout remaining participants
                if (event.participants && Array.isArray(event.participants)) {
                    event.participants.forEach(p => {
                        if (p && !p.checkOutTime) { // Check participant exists
                            p.checkOutTime = now;
                            // Optionally record a default location or null
                            p.checkOutLocation = null; // Or attempt to get current location here? Simpler to null.
                            checkedOutCount++;
                        }
                    });
                }


                event.closed = true;
                await updateItem(EVENTS_STORE_NAME, event);

                showMessage(adminMessage, `Event closed successfully. ${checkedOutCount} participant(s) automatically checked out.`, 'success');
                closeEventDetailsModal();
                await displayEvents(); // Refresh the main event list

            } catch (error) {
                console.error("Error closing event:", error);
                 showMessage(adminMessage, `Failed to close event: ${error}`, 'error');
            }
        }

        /**
         * Handles the deletion of an event.
         */
        async function handleDeleteEvent() {
             if (currentEditEventId === null) return;
             hideMessage(adminMessage);

             if (!confirm(`ARE YOU SURE you want to permanently delete event ID ${currentEditEventId}? This action cannot be undone.`)) {
                 return;
             }

             try {
                 await deleteItem(EVENTS_STORE_NAME, currentEditEventId);
                 showMessage(adminMessage, `Event ID ${currentEditEventId} deleted successfully.`, 'success');
                 closeEventDetailsModal();
                 await displayEvents(); // Refresh the main event list

             } catch (error) {
                 console.error("Error deleting event:", error);
                 showMessage(adminMessage, `Failed to delete event: ${error}`, 'error');
             }
        }

        // --- Reporting and Export Logic ---

        /**
         * Safely gets location string for exports.
         * @param {object | null | undefined} locationObj - The location object {latitude, longitude}.
         * @param {'lat' | 'lon'} type - Which coordinate to return.
         * @returns {string} - Formatted coordinate or 'N/A'.
         */
        function getLocationStringForExport(locationObj, type) {
            if (!locationObj || typeof locationObj.latitude !== 'number' || typeof locationObj.longitude !== 'number' || isNaN(locationObj.latitude) || isNaN(locationObj.longitude)) {
                return 'N/A';
            }
            try {
                return type === 'lat' ? locationObj.latitude.toFixed(6) : locationObj.longitude.toFixed(6);
            } catch (e) {
                return 'Invalid';
            }
        }


        /**
         * Generates CSV data for the current event in the modal.
         */
        async function generateCsv() {
            if (currentEditEventId === null) return;
            hideMessage(adminMessage);

            try {
                const event = await getItem(EVENTS_STORE_NAME, currentEditEventId);
                if (!event || !event.participants || event.participants.length === 0) {
                    showMessage(adminMessage, "No participant data found for CSV export.", "warning");
                    return;
                }

                const dataToExport = event.participants.map(p => ({
                    "First Name": p?.firstName || 'N/A',
                    "Last Name": p?.lastName || '',
                    "SAR Number": p?.sarNumber || 'N/A',
                    "First Aid": p?.firstAidLevel || 'N/A',
                    "Phone": p?.phoneNumber || 'N/A',
                    "Check-In Time": formatDate(p?.checkInTime),
                    "Check-In Lat": getLocationStringForExport(p?.checkInLocation, 'lat'),
                    "Check-In Lon": getLocationStringForExport(p?.checkInLocation, 'lon'),
                    "Check-Out Time": formatDate(p?.checkOutTime),
                    "Check-Out Lat": getLocationStringForExport(p?.checkOutLocation, 'lat'),
                    "Check-Out Lon": getLocationStringForExport(p?.checkOutLocation, 'lon'),
                    "Total Hours": calculateHours(p?.checkInTime, p?.checkOutTime)
                }));


                const csv = Papa.unparse(dataToExport);
                const blob = new Blob([`\uFEFF${csv}`], { type: 'text/csv;charset=utf-8;' }); // Add BOM for Excel compatibility
                const link = document.createElement("a");
                const url = URL.createObjectURL(blob);
                // Sanitize event name for filename
                const safeEventName = (event.eventName || 'Event').replace(/[^a-z0-9]/gi, '_').toLowerCase();
                const filename = `SAR_Event_${safeEventName}_${event.id}.csv`;

                link.setAttribute("href", url);
                link.setAttribute("download", filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url); // Clean up blob URL

                showMessage(adminMessage, "CSV file generated.", "success");

            } catch (error) {
                 console.error("Error generating CSV:", error);
                 showMessage(adminMessage, `Failed to generate CSV: ${error}`, 'error');
            }
        }

        /**
         * Generates PDF data for the current event in the modal.
         * Uses jsPDF with basic text layout.
         */
        async function generatePdf() {
            if (currentEditEventId === null) return;
             hideMessage(adminMessage);

            // Ensure jsPDF is loaded (it's included via CDN)
            if (typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined') {
                 showMessage(adminMessage, "PDF library (jsPDF) not loaded.", "error");
                 return;
            }
            const { jsPDF } = window.jspdf; // Destructure from the global object

            try {
                const event = await getItem(EVENTS_STORE_NAME, currentEditEventId);
                 if (!event) {
                     showMessage(adminMessage, "Event data not found for PDF export.", "warning");
                     return;
                 }

                const doc = new jsPDF({ orientation: 'landscape' }); // Use landscape for more table width
                let yPos = 15; // Starting Y position
                const pageHeight = doc.internal.pageSize.height;
                const leftMargin = 10;
                const rightMargin = doc.internal.pageSize.width - leftMargin;

                function checkAddPage(increment = 5) {
                    if (yPos + increment > pageHeight - 15) { // Check if space remaining
                        doc.addPage();
                        yPos = 15; // Reset Y on new page
                        // Optionally repeat headers
                        // addHeaderRow();
                    } else {
                        yPos += increment;
                    }
                }

                 // --- Event Header ---
                doc.setFontSize(16);
                doc.text(`SAR Event Report: ${event.eventName || 'N/A'}`, leftMargin, yPos);
                checkAddPage(8);
                doc.setFontSize(10);
                doc.text(`Type: ${event.eventType || 'N/A'}`, leftMargin, yPos);
                checkAddPage(5);
                doc.text(`Created: ${formatDate(event.creationTime)}`, leftMargin, yPos);
                checkAddPage(5);
                doc.text(`Status: ${event.closed ? 'Closed' : 'Active'}`, leftMargin, yPos);
                 checkAddPage(5);
                 // Safely add location
                 let pdfLocationString = 'Location: Not specified';
                 if (event.location && typeof event.location.latitude === 'number' && typeof event.location.longitude === 'number' && !isNaN(event.location.latitude) && !isNaN(event.location.longitude)) {
                     try {
                         pdfLocationString = `Location: ${event.location.latitude.toFixed(4)}, ${event.location.longitude.toFixed(4)}`;
                     } catch { pdfLocationString = 'Location: Invalid data'; }
                 }
                 doc.text(pdfLocationString, leftMargin, yPos);
                 checkAddPage(10); // Add space before participants


                // --- Participants Data ---
                if (event.participants && event.participants.length > 0) {
                    doc.setFontSize(12);
                    doc.text("Participants:", leftMargin, yPos);
                    checkAddPage(7);
                    doc.setFontSize(9);

                    // Simple Header Row Function
                    const headers = ["Name", "SAR#", "Check-In", "In Loc", "Check-Out", "Out Loc", "Hours"];
                    const colWidths = [45, 25, 40, 35, 40, 35, 20]; // Adjusted for landscape

                    function addHeaderRow() {
                        doc.setFont(undefined, 'bold'); // Make header bold
                        let xPosH = leftMargin;
                        headers.forEach((header, i) => {
                            doc.text(header, xPosH, yPos);
                            xPosH += colWidths[i];
                        });
                        doc.setFont(undefined, 'normal'); // Reset font style
                        checkAddPage(2);
                        doc.setLineWidth(0.2);
                        doc.line(leftMargin, yPos, rightMargin - 5, yPos); // Line below header
                        checkAddPage(5);
                    }

                    addHeaderRow(); // Add header initially

                    // Data Rows
                    event.participants.forEach(p => {
                         checkAddPage(7); // Check space before adding row content
                         if (yPos === 15 && doc.internal.getNumberOfPages() > 1) { // If new page was added
                            addHeaderRow(); // Repeat header
                         }

                         let xPos = leftMargin;
                         const name = `${p?.firstName || 'N/A'} ${p?.lastName || ''}`;
                         const checkIn = formatDate(p?.checkInTime);
                         const checkOut = formatDate(p?.checkOutTime);
                         const hours = calculateHours(p?.checkInTime, p?.checkOutTime);
                         const inLoc = p?.checkInLocation ? `${getLocationStringForExport(p.checkInLocation, 'lat')}, ${getLocationStringForExport(p.checkInLocation, 'lon')}` : 'N/A';
                         const outLoc = p?.checkOutLocation ? `${getLocationStringForExport(p.checkOutLocation, 'lat')}, ${getLocationStringForExport(p.checkOutLocation, 'lon')}` : 'N/A';


                         doc.text(name, xPos, yPos, { maxWidth: colWidths[0] - 2 });
                         xPos += colWidths[0];
                         doc.text(p?.sarNumber || 'N/A', xPos, yPos);
                         xPos += colWidths[1];
                         doc.text(checkIn, xPos, yPos);
                         xPos += colWidths[2];
                         doc.text(inLoc, xPos, yPos, { maxWidth: colWidths[3] - 2 });
                         xPos += colWidths[3];
                         doc.text(checkOut, xPos, yPos);
                         xPos += colWidths[4];
                         doc.text(outLoc, xPos, yPos, { maxWidth: colWidths[5] - 2 });
                         xPos += colWidths[5];
                         doc.text(hours, xPos, yPos);

                    });
                } else {
                     doc.text("No participants recorded for this event.", leftMargin, yPos);
                }


                // Save the PDF
                 const safeEventName = (event.eventName || 'Event').replace(/[^a-z0-9]/gi, '_').toLowerCase();
                 const filename = `SAR_Event_${safeEventName}_${event.id}.pdf`;
                doc.save(filename);
                 showMessage(adminMessage, "PDF file generated.", "success");

            } catch (error) {
                 console.error("Error generating PDF:", error);
                 showMessage(adminMessage, `Failed to generate PDF: ${error}`, 'error');
            }
        }

        /**
         * Generates an email draft using the mailto: protocol.
         */
        async function generateEmail() {
             if (currentEditEventId === null) return;
             hideMessage(adminMessage);

             try {
                 const event = await getItem(EVENTS_STORE_NAME, currentEditEventId);
                 if (!event) {
                     showMessage(adminMessage, "Event data not found for email.", "warning");
                     return;
                 }

                 let body = `SAR Event Report\n`;
                 body += `--------------------\n`;
                 body += `Event Name: ${event.eventName || 'N/A'}\n`;
                 body += `Type: ${event.eventType || 'N/A'}\n`;
                 body += `Created: ${formatDate(event.creationTime)}\n`;
                 body += `Status: ${event.closed ? 'Closed' : 'Active'}\n`;
                  // Safely add location
                 let emailLocationString = 'Location: Not specified';
                 if (event.location && typeof event.location.latitude === 'number' && typeof event.location.longitude === 'number' && !isNaN(event.location.latitude) && !isNaN(event.location.longitude)) {
                     try {
                         emailLocationString = `Location: ${event.location.latitude.toFixed(4)}, ${event.location.longitude.toFixed(4)}`;
                     } catch { emailLocationString = 'Location: Invalid data'; }
                 }
                 body += `${emailLocationString}\n`;
                 body += `--------------------\n\n`;
                 body += `Participants:\n`;

                 if (event.participants && event.participants.length > 0) {
                     event.participants.forEach(p => {
                         if (!p) return; // Skip if participant data is null
                         body += `\n- ${p.firstName || 'N/A'} ${p.lastName || ''} (SAR# ${p.sarNumber || 'N/A'})\n`;
                         body += `  Check-In: ${formatDate(p.checkInTime)}\n`;
                         const inLoc = p.checkInLocation ? `${getLocationStringForExport(p.checkInLocation, 'lat')}, ${getLocationStringForExport(p.checkInLocation, 'lon')}` : 'N/A';
                         body += `  Check-In Loc: ${inLoc}\n`;
                         body += `  Check-Out: ${formatDate(p.checkOutTime)}\n`;
                          const outLoc = p.checkOutLocation ? `${getLocationStringForExport(p.checkOutLocation, 'lat')}, ${getLocationStringForExport(p.checkOutLocation, 'lon')}` : 'N/A';
                         body += `  Check-Out Loc: ${outLoc}\n`;
                         body += `  Total Hours: ${calculateHours(p.checkInTime, p.checkOutTime)}\n`;
                     });
                 } else {
                     body += `No participants recorded.\n`;
                 }

                 const subject = `SAR Event Report: ${event.eventName || 'N/A'}`;
                 const mailtoLink = `mailto:?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

                 // Attempt to open the mail client
                 // Use window.open for potentially better compatibility than window.location.href
                 if (mailtoLink.length > 2000) { // Check for URL length limits
                     showMessage(adminMessage, "Report is too long for email link. Please use CSV/PDF export.", "warning");
                 } else {
                     window.open(mailtoLink, '_blank');
                     showMessage(adminMessage, "Attempting to open email client...", "info");
                 }


             } catch (error) {
                 console.error("Error generating email:", error);
                 showMessage(adminMessage, `Failed to generate email: ${error}`, 'error');
             }
        }


        // --- PWA Service Worker Registration ---
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                // Register sw.js relative to the HTML file's location
                navigator.serviceWorker.register('./sw.js') // Ensure correct path
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                        // Optional: Listen for updates
                        registration.onupdatefound = () => {
                            const installingWorker = registration.installing;
                            if (installingWorker) {
                                installingWorker.onstatechange = () => {
                                    if (installingWorker.state === 'installed') {
                                        if (navigator.serviceWorker.controller) {
                                            // New update available
                                            console.log('New content is available; please refresh.');
                                            // Optionally show a notification to the user
                                            // showMessage(adminMessage, 'App update available! Refresh page.', 'info', 0);
                                        } else {
                                            // Content is cached for the first time
                                            console.log('Content is cached for offline use.');
                                        }
                                    }
                                };
                            }
                        };
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                         // Show non-critical error to user?
                         showMessage(adminMessage, 'Offline mode might not be available (SW registration failed).', 'warning');
                    });
            } else {
                 console.warn('Service workers are not supported in this browser.');
                 showMessage(adminMessage, 'Offline mode not fully supported by this browser.', 'warning');
            }
        }


        // --- Initialization and Event Listeners ---

        /**
         * Initializes the application.
         */
        async function initializeApp() {
            // App Selection Buttons
            showUserAppBtn.addEventListener('click', () => {
                userAppSection.classList.remove('hidden');
                adminAppSection.classList.add('hidden');
                showUserAppBtn.classList.replace('btn-secondary', 'btn-primary');
                showAdminAppBtn.classList.replace('btn-primary', 'btn-secondary');
                 stopScanner(); // Stop scanner if switching away from admin
            });
            showAdminAppBtn.addEventListener('click', () => {
                userAppSection.classList.add('hidden');
                adminAppSection.classList.remove('hidden');
                showUserAppBtn.classList.replace('btn-primary', 'btn-secondary');
                showAdminAppBtn.classList.replace('btn-secondary', 'btn-primary');
                // Load admin data when switching to it
                displayEvents(); // Refresh events list
                switchAdminView('eventsView'); // Default to events view
            });

            // User App Event Listeners
            userForm.addEventListener('submit', (e) => {
                e.preventDefault();
                saveUserData();
            });
            generateQrBtn.addEventListener('click', generateQRCode);
            clearUserFormBtn.addEventListener('click', clearUserForm);

            // Admin App Event Listeners
            tabEvents.addEventListener('click', () => {
                switchAdminView('eventsView');
                displayEvents(); // Refresh events when switching to the tab
            });
            tabCreateEvent.addEventListener('click', () => switchAdminView('createEventView'));
            tabScanQR.addEventListener('click', () => switchAdminView('scanQrView'));
            createEventForm.addEventListener('submit', handleCreateEvent);
            getEventLocationBtn.addEventListener('click', handleGetEventLocation);
            eventFilter.addEventListener('change', displayEvents);
            startScanBtn.addEventListener('click', startScanner);
            stopScanBtn.addEventListener('click', stopScanner);

            // Modal Event Listeners
            closeModalBtn.addEventListener('click', closeEventDetailsModal);
            exportCsvBtn.addEventListener('click', generateCsv);
            exportPdfBtn.addEventListener('click', generatePdf);
            emailReportBtn.addEventListener('click', generateEmail);
            closeEventBtn.addEventListener('click', handleCloseEvent);
            deleteEventBtn.addEventListener('click', handleDeleteEvent);
            // Debounce participant search slightly to avoid excessive DB reads
            let searchTimeout;
            participantSearch.addEventListener('input', (e) => {
                 clearTimeout(searchTimeout);
                 searchTimeout = setTimeout(async () => {
                     if (currentEditEventId !== null) {
                         try {
                             const event = await getItem(EVENTS_STORE_NAME, currentEditEventId);
                             if (event) {
                                 renderParticipantsTable(event.participants || [], e.target.value);
                             }
                         } catch (err) { console.error("Error searching participants:", err);}
                     }
                 }, 300); // Wait 300ms after user stops typing
            });


            // Checkout Confirmation Modal Listeners
            cancelCheckoutBtn.addEventListener('click', () => {
                checkoutConfirmModal.classList.remove('active');
                userToCheckOut = null;
            });
            confirmCheckoutBtn.addEventListener('click', handleConfirmCheckout);

             // Close modals if clicking outside the content area
            eventDetailsModal.addEventListener('click', (e) => {
                if (e.target === eventDetailsModal) { // Check if the click is on the backdrop
                    closeEventDetailsModal();
                }
            });
             checkoutConfirmModal.addEventListener('click', (e) => {
                if (e.target === checkoutConfirmModal) {
                    checkoutConfirmModal.classList.remove('active');
                    userToCheckOut = null;
                }
            });


            // --- Initial Load ---
            loadUserData(); // Load user data on start

            try {
                await openDatabase(); // Open IndexedDB
                // Initially show user app by default
                showUserAppBtn.click();
                // No need to load admin events immediately, wait until user switches
            } catch (error) {
                console.error("Failed to initialize database:", error);
                 showMessage(adminMessage, `Critical Error: Could not initialize database. Admin features unavailable. ${error}`, 'error', 0);
                 // Disable admin features if DB fails?
                 showAdminAppBtn.disabled = true;
                 tabEvents.disabled = true;
                 tabCreateEvent.disabled = true;
                 tabScanQR.disabled = true;
            }

            registerServiceWorker(); // Register the service worker
        }

        // --- Start the app ---
        // Use 'load' event to ensure all resources including images might be loaded,
        // although DOMContentLoaded is usually sufficient for script execution.
        // window.addEventListener('load', initializeApp);
        document.addEventListener('DOMContentLoaded', initializeApp);


    </script>

    </body>
</html>
